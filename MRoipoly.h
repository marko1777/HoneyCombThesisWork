/*!
 * \file
 * MRoipoly class definition. This file is part of DataFilters module of MSC SDK.
 *
 * \remarks
 * Copyright (C) 2018 Mediso. All rights reserved.
 *
 * \authors
 * pmark
 */
#pragma once

#include <MDR/include/MIndex.h>
#include <ScientificCore/include/Export.h>
#include <cmath>
#include <vector>

namespace msc
{

/*!
 * \brief Specify polygonal region of interest https://www.mathworks.com/help/images/ref/roipoly.html
 */
class ScientificCore_API MRoipoly
{
	enum class Orientation
	{
		Colinear		 = 0,
		ClockWise		 = 1,
		CounterClockWise = 2
	};

	using PolygonType = std::vector<mcp::MIndex2D<std::uint64_t>>;

	struct TripletPoint
	{
		mcp::MIndex2D<std::uint64_t> m_P;
		mcp::MIndex2D<std::uint64_t> m_Q;
		mcp::MIndex2D<std::uint64_t> m_R;
	};

public:
	/*!
	 * Constructor
	 * \param [in] aDimX: first dimension of the space where roi should be checked
	 * \param [in] aDimY: second dimension of the space where roi should be checked
	 */
	MRoipoly( std::uint64_t aDimX, std::uint64_t aDimY );

	/*!
	 * \brief Specify polygonal region of interest
	 * \param [in] aPointsX: the first coordinates of the polygon points
	 * \param [in] aPointsY: the second coordinates of the polygon points
	 * \param [out] [coordinates]: vector of x, y coordinates where the aPolygon
	 * is inside the plane generated by the dimensions
	 */
	PolygonType mask(
		const std::vector<std::uint64_t>& aPointsX,
		const std::vector<std::uint64_t>& aPointsY );

	/*!
	 * \brief Specify polygonal region of interest
	 * \param [in] aPolygon: the polygon coordinates grouped in pairs
	 * \param [out] [coordinates]: vector of x, y coordinates where the aPolygon
	 * is inside the plane generated by the dimensions
	 */
	PolygonType mask( const std::vector<mcp::MIndex2D<std::uint64_t>>& aPolygon );

private:
	/*!
	 * \brief mask implementation
	 */
	PolygonType maskImpl();

	/*!
	 * \brief initalize boundaries
	 */
	void init();

	/*!
	 *\brief Given three colinear points p, q, r, the function checks if point q
	 *lies on line segment 'pr' \param [in] aPoints: three colinear points \param
	 *[out]: q lies on segment 'pr'
	 */
	bool onSegment( const TripletPoint& aPoints );

	/*!
	 * \brief To find orientation of ordered triplet (p, q, r)
	 * \param [in] aPoints: three colinear points
	 * \param [out]: 0 --> p, q and r are colinear; 1 --> Clockwise; 2 --> Counterclockwise;
	 */
	Orientation orientation( const TripletPoint& aPoints );

	/*!
	 * \brief Determine if 'pq' line segment intersects with 'raExtraPoint'
	 * \param [in] aTripletPoint: three colinear points
	 * \param [in] aExtraPoint: another point
	 * \param [out]: 'pq' line segment intersects with 'raExtraPoint'
	 */
	bool doIntersect( const TripletPoint& aTripletPoint, mcp::MIndex2D<std::uint64_t> aExtraPoint );

	/*!
	 * \brief Determine if the point aP lies inside the m_Polygon
	 * \param [in] aP: point
	 * \param [out]: aP lies insidee the polygon
	 */
	bool pointInPolygon( mcp::MIndex2D<std::uint64_t> aP );

private:
	std::vector<mcp::MIndex2D<std::uint64_t>> m_Polygon; /*! \var the polygon */
	std::uint64_t							  m_DimX;
	std::uint64_t							  m_DimY;
	std::uint64_t							  m_XMax;
	std::uint64_t							  m_XMin;
	std::uint64_t							  m_YMin;
	std::uint64_t							  m_YMax;
};
} // namespace msc